<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-05-01T13:12:17+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">超越技术</title><subtitle>超越技术，专注于图解计算机通用技术，比如图解算法、图解数据结构。目前正在做图解LeetCode算法和数据结构。我希望作为一名”说人话“的技术人。</subtitle><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2019/05/01/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2019-05-01T09:28:47+08:00</published><updated>2019-05-01T09:28:47+08:00</updated><id>http://localhost:4000/jekyll/update/2019/05/01/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/05/01/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2019/05/01/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2019-05-01T09:28:47+08:00</published><updated>2019-05-01T09:28:47+08:00</updated><id>http://localhost:4000/jekyll/update/2019/05/01/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/05/01/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">图解LeetCode!</title><link href="http://localhost:4000/jekyll/update/2019/04/05/%E5%9B%BE%E8%A7%A3LeetCode.html" rel="alternate" type="text/html" title="图解LeetCode!" /><published>2019-04-05T09:28:47+08:00</published><updated>2019-04-05T09:28:47+08:00</updated><id>http://localhost:4000/jekyll/update/2019/04/05/%E5%9B%BE%E8%A7%A3LeetCode</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/04/05/%E5%9B%BE%E8%A7%A3LeetCode.html">&lt;h1 id=&quot;leetcodegraphically&quot;&gt;LeetCodeGraphically&lt;/h1&gt;

&lt;h3 id=&quot;图解-leetcode-算法让算法活起来&quot;&gt;图解 LeetCode 算法，让算法”活”起来。&lt;/h3&gt;

&lt;p&gt;数据结构和算法是面试非常重要的内容，有些算法非常难以理解，仅靠文字描述很难让读者明白算法思想。如果通过图示的方式来描述算法和数据结构，会形象很多，读者也容易理解算法的真实含义。&lt;/p&gt;

&lt;p&gt;这个项目目的是让学习数据结构和算法变得更轻松，我会逐步解析LeetCode上的题目，在学习算法的同时也会讲解设计到的数据结构。&lt;/p&gt;

&lt;h2 id=&quot;公众号&quot;&gt;公众号&lt;/h2&gt;

&lt;p&gt;图解算法相关的文章每天都会在公众号发布，欢迎关注我的公众号「超越技术」，和我一同学习！！！&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/cyjs_qr.png?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;图解排序算法&quot;&gt;图解排序算法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/code/LeetCodeGraphically/LeetCodeGraphically/LEFSortManager.h&quot;&gt;代码位置&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483822&amp;amp;idx=1&amp;amp;sn=ff5b8abd13ac4e89953dd07f16eca8d3&amp;amp;chksm=fabb013dcdcc882be39d9aad8c462de93eb7bcf49234caa5dd7403cc67bb84f4d2168a1952a5&amp;amp;scene=21#wechat_redirect&quot;&gt;图解排序 1/10 - 冒泡排序&lt;/a&gt;&lt;/th&gt;
      &lt;th&gt;冒泡排序是通过比较两个相邻元素的大小实现排序，如果前一个元素大于后一个元素，就交换这两个元素&lt;/th&gt;
      &lt;th&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/maopao.jpeg?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483828&amp;amp;idx=1&amp;amp;sn=d8f0675f4e54e3b273c90c59be54eaeb&amp;amp;chksm=fabb0127cdcc883158bb0791f26cae1ea8494b496744f802b22babb4c03eaaef25e98dfbff57&amp;amp;scene=21#wechat_redirect&quot;&gt;图解排序 2/10 - 插入排序&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;选择排序的核心思想是把一个待排序序列，分成 2 部分，前半部分为有序序列，后半部分为无序序列，遍历后半部分数据，插入到前半部分已经排序好的序列，最终得到一个有序序列&lt;/td&gt;
      &lt;td&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/charu.jpeg?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483834&amp;amp;idx=1&amp;amp;sn=d91d9d354d765da8bece9c06510f3a5d&amp;amp;chksm=fabb0129cdcc883f5c48e76a7690b4fe698415827c82c8ef4c8482a8618fdff05258f13eff03&amp;amp;token=623725354&amp;amp;lang=zh_CN#rd&quot;&gt;图解排序 3/10 - 希尔排序&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;把一个序列分组，对分组后的内容进行&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483828&amp;amp;idx=1&amp;amp;sn=d8f0675f4e54e3b273c90c59be54eaeb&amp;amp;chksm=fabb0127cdcc883158bb0791f26cae1ea8494b496744f802b22babb4c03eaaef25e98dfbff57&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;strong&gt;插入排序&lt;/strong&gt;&lt;/a&gt;，这里的分组只是逻辑上的分组，不会重新开辟存储空间&lt;/td&gt;
      &lt;td&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/shell.001.jpeg?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483843&amp;amp;idx=1&amp;amp;sn=0d0e23585aacaa4a291c201a155f7617&amp;amp;chksm=fabb0150cdcc88464eacf4f6b60a0562171658cb4e0c6262b2fb9ecd02c194e58faae777ab0f&amp;amp;scene=21#wechat_redirect&quot;&gt;图解排序 4/10 - 快速排序&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;对待排序序列通过一个「支点」（支点就是序列中的一个元素，别把它想的太高大上）进行拆分，使得左边的数据小于支点，右边的数据大于支点。然后把左边和右边再做一次递归，直到递归结束&lt;/td&gt;
      &lt;td&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/quick.001.jpeg?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483848&amp;amp;idx=1&amp;amp;sn=35145839503cf88a88fdd6e964a6c90d&amp;amp;chksm=fabb015bcdcc884d06dccf879889abed4f680cbb62e07aae65a82ce7f7a28de9a0c29d0c0cce&amp;amp;scene=21#wechat_redirect&quot;&gt;图解排序 5/10 - 归并排序&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;归并排序，采用分治思想，先把待排序序列拆分成一个个子序列，直到子序列只有一个元素，停止拆分，然后对每个子序列进行边排序边合并&lt;/td&gt;
      &lt;td&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/guibing.001.jpeg?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483889&amp;amp;idx=1&amp;amp;sn=4c92c6d9fdb9b0fbc3cc99ee1a2fcadf&amp;amp;chksm=fabb0162cdcc8874bb601ed836f996dcd849f50993960d07e34539f6779b2dc295fcad0d4d63&amp;amp;scene=21#wechat_redirect&quot;&gt;图解排序 6/10 - 堆排序&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;堆排序需要借助于一种数据结构「堆」，注意下文说的都是 「大根堆」。排序的过程中需要不断进行重组堆（heapify 阶段）&lt;/td&gt;
      &lt;td&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/heap.003.jpeg?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483892&amp;amp;idx=1&amp;amp;sn=2af95b49be0ac263a9fa16444c06a360&amp;amp;chksm=fabb0167cdcc8871c15cf1bb85ef625cc4395e91cbe8f81bdbcb1e47a3d8af30310b0adb4f79&amp;amp;scene=21#wechat_redirect&quot;&gt;图解排序 7/10 - 计数排序&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;计数排序的核心思想是把一个无序序列 A 转换成另一个有序序列 B，从 B 中逐个“取出”所有元素，取出的元素即为有序序列&lt;/td&gt;
      &lt;td&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/count.001.jpeg?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483894&amp;amp;idx=1&amp;amp;sn=050c2d219cc16021db0f6cec83045257&amp;amp;chksm=fabb0165cdcc88737c673df3424b615e0e64cc5a0501d9c97cd26bfcff651a60a2d19a43f585&amp;amp;scene=21#wechat_redirect&quot;&gt;图解排序 8/10 - 桶排序&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;桶排序的核心思想是把数据分到若干个“桶”中，对“桶”中的元素进行排序，最终把“桶”中已排序好的数据合并为一个有序序列。&lt;/td&gt;
      &lt;td&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/bucket.001.jpeg?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483895&amp;amp;idx=1&amp;amp;sn=0c3097272d4587963a026cf699d10ce0&amp;amp;chksm=fabb0164cdcc88724dfaebd98087baa914f33253bd9278c95f48859529f34943185e83ee2f62&amp;amp;scene=21#wechat_redirect&quot;&gt;图解排序 9/10 - 基数排序&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;基数排序是从待排序序列找出可以作为排序的「关键字」，按照「关键字」进行多次排序，最终得到有序序列。&lt;/td&gt;
      &lt;td&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/diget.001.jpeg?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483897&amp;amp;idx=1&amp;amp;sn=8fd337d568a9f56fd1e926fb1012565c&amp;amp;chksm=fabb016acdcc887ce4f0e438a4fb2704c62cf4996a0abda2f2f2f6a629d52aef3be01df46010&amp;amp;scene=21#wechat_redirect&quot;&gt;图解排序 10/10 - 选择排序&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;选择排序的思想是，依次从「无序列表」中找到一个最小的元素放到「有序列表」的最后面&lt;/td&gt;
      &lt;td&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/xuanze.jpeg?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;图解leetcode链表相关算法&quot;&gt;图解LeetCode链表相关算法&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/code/LeetCodeGraphically/LeetCodeGraphically/LEFListSubject.hpp&quot;&gt;代码位置&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483939&amp;amp;idx=1&amp;amp;sn=5e68e353c5216ff197b8403152d03c02&amp;amp;chksm=fabb02b0cdcc8ba6fab84dca5b239dd44f0d1924fa5c559b681688c46ca885e00f0b93b9fe9a&amp;amp;token=623725354&amp;amp;lang=zh_CN#rd&quot;&gt;图解 LeetCode 链表: 83. Remove Duplicates from Sorted List&lt;/a&gt;&lt;/th&gt;
      &lt;th&gt;给定一个「有序」的链表，去掉重复的节点，每个节点只能出现一次&lt;/th&gt;
      &lt;th&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/let_83.png?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483940&amp;amp;idx=1&amp;amp;sn=0f71bdcf10b28e523770b8d7d10acbd8&amp;amp;chksm=fabb02b7cdcc8ba1a00c9018834d480bddeeac837d57e7c2940619aafd5b418f1ebfa564c2dd&amp;amp;token=623725354&amp;amp;lang=zh_CN#rd&quot;&gt;图解 LeetCode 链表: 82. Remove Duplicates from Sorted List II&lt;/a&gt;&lt;/td&gt;
      &lt;td&gt;移除链表中出现过多次的节点，解这道题的思路也是「水管思路」，对水管进行拆分，重组。链表中可能出现多个重复节点，需要把这些重复的节点全部干掉&lt;/td&gt;
      &lt;td&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/let_82.png?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">LeetCodeGraphically</summary></entry><entry><title type="html">图解排序 1/10 - 冒泡排序</title><link href="http://localhost:4000/jekyll/update/2019/04/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html" rel="alternate" type="text/html" title="图解排序 1/10 - 冒泡排序" /><published>2019-04-01T09:28:47+08:00</published><updated>2019-04-01T09:28:47+08:00</updated><id>http://localhost:4000/jekyll/update/2019/04/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/04/01/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html">&lt;blockquote&gt;
  &lt;p&gt;本文首次发表于超越技术公众号 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483822&amp;amp;idx=1&amp;amp;sn=ff5b8abd13ac4e89953dd07f16eca8d3&amp;amp;chksm=fabb013dcdcc882be39d9aad8c462de93eb7bcf49234caa5dd7403cc67bb84f4d2168a1952a5&amp;amp;scene=21#wechat_redirect&quot;&gt;图解排序 1/10 - 冒泡排序&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近温习了10个经典的排序算法：冒泡排序、选择排序、直接插入排序、希尔排序、快速排序、归并排序、堆排序、计数排序、桶排序和基数排序。每个算法都使用 keynote 画出了算法的整个执行过程，使用图的形式会加深对算法思想的理解，如果在学习过程中能找到相关排序算法视频，学起来会更快一些。在整个学习过程中，发现如果光看纯文字的博客，或者算法书籍对理解算法非常吃力。所有我想通过图文的形式来表达我对这10种算法的理解，希望对你有所启发。&lt;/p&gt;

&lt;p&gt;排序算法的思想就是把一堆无序的数据采用某一种方法让它变得有序，而通常由于数据的组合形式不同，采用不同的方法有助于提升排序效率，这就是为什么会有这么多的排序算法的原因（纯属个人理解）。&lt;/p&gt;

&lt;p&gt;我会用10篇文章来说明各个排序算法，并会用OC代码实现算法。后续文章涉及到的排序算法都是以整形数为例。这些文章目的是让你理解排序算法的思想，所以算法实现方面，我省略了很多异常处理。&lt;/p&gt;

&lt;h4 id=&quot;冒泡排序&quot;&gt;冒泡排序&lt;/h4&gt;

&lt;p&gt;冒泡排序是通过比较两个相邻元素的大小实现排序，如果后一个元素大于前一个元素，就交换这两个元素。这样就会让每一趟冒泡都能找到最大一个元素并放到最后。&lt;/p&gt;

&lt;p&gt;以 [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，对它进行冒泡排序：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/lefex/lefex.github.io/blob/master/images/all.005.jpeg?raw=true&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/lefex/lefex.github.io/blob/master/images/all.005.jpeg?raw=true&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/lefex/lefex.github.io/blob/master/images/all.005.jpeg?raw=true&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;代码实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (NSArray *)bubbleSort:(NSArray *)unsortDatas {    NSMutableArray *unSortArray = [unsortDatas mutableCopy];    for (int i = 0; i &amp;lt; unSortArray.count -1 ; i++) {        BOOL isChange = NO;        for (int j = 0; j &amp;lt; unSortArray.count - 1 - i; j++) {            // 比较相邻两个元素的大小，后一个大于前一个就交换            if ([unSortArray[j] integerValue] &amp;gt; [unSortArray[j+1] integerValue]) {                NSNumber *data = unSortArray[j+1];                unSortArray[j+1] = unSortArray[j];                unSortArray[j] = data;                isChange = YES;            }        }        if (!isChange) {            // 如果某次未发生数据交换，说明数据已排序            break;        }    }    return [unSortArray copy];}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;特点&quot;&gt;特点&lt;/h4&gt;

&lt;p&gt;稳定性：它是指对同样的数据进行排序，会不会改变它的相对位置。比如 [ 1, 3, 2, 4, 2 ] 经过排序后，两个相同的元素 2 位置会不会被交换。冒泡排序是比较相邻两个元素的大小，显然不会破坏稳定性。&lt;/p&gt;

&lt;p&gt;空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1);&lt;/p&gt;

&lt;p&gt;时间复杂度：最后的情况 O(n*n)，平均为 O(nlgn);&lt;/p&gt;

&lt;h4 id=&quot;感想&quot;&gt;感想&lt;/h4&gt;

&lt;p&gt;冒泡排序在排序的过程中设置一个 Flag 标记是否已经有序，会减少冒泡排序的趟数。它更适合基本有序的数据，只有几个无序，最好的情况时间复杂度为 O ( n )。它的基本操是每次找出最大的元素放到最后。&lt;/p&gt;

&lt;h4 id=&quot;推荐阅读&quot;&gt;推荐阅读：&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&amp;amp;mid=2247483806&amp;amp;idx=1&amp;amp;sn=b85f43e846e96433755c7dc6adc1d033&amp;amp;chksm=fabb010dcdcc881b242ad387e6da4ea4174b99f5423d7bed11cc07dcd2af92f3ac00ebfc4ee8&amp;amp;scene=21#wechat_redirect&quot;&gt;编程的背后&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;border-radius: 30px&quot; src=&quot;https://github.com/lefex/LeetCodeGraphically/blob/master/images/cyjs_qr.png?raw=true&quot; title=&quot;lefex&quot; width=&quot;200&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">本文首次发表于超越技术公众号 图解排序 1/10 - 冒泡排序</summary></entry></feed>