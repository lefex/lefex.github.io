---
layout: post
title:  "图解排序 1/10 - 冒泡排序"
date:   2019-04-01 09:28:47 +0800
categories: jekyll update
---

> 本文首次发表于超越技术公众号 [图解排序 1/10 - 冒泡排序](https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&mid=2247483822&idx=1&sn=ff5b8abd13ac4e89953dd07f16eca8d3&chksm=fabb013dcdcc882be39d9aad8c462de93eb7bcf49234caa5dd7403cc67bb84f4d2168a1952a5&scene=21#wechat_redirect)



最近温习了10个经典的排序算法：冒泡排序、选择排序、直接插入排序、希尔排序、快速排序、归并排序、堆排序、计数排序、桶排序和基数排序。每个算法都使用 keynote 画出了算法的整个执行过程，使用图的形式会加深对算法思想的理解，如果在学习过程中能找到相关排序算法视频，学起来会更快一些。在整个学习过程中，发现如果光看纯文字的博客，或者算法书籍对理解算法非常吃力。所有我想通过图文的形式来表达我对这10种算法的理解，希望对你有所启发。

排序算法的思想就是把一堆无序的数据采用某一种方法让它变得有序，而通常由于数据的组合形式不同，采用不同的方法有助于提升排序效率，这就是为什么会有这么多的排序算法的原因（纯属个人理解）。

我会用10篇文章来说明各个排序算法，并会用OC代码实现算法。后续文章涉及到的排序算法都是以整形数为例。这些文章目的是让你理解排序算法的思想，所以算法实现方面，我省略了很多异常处理。

#### 冒泡排序

冒泡排序是通过比较两个相邻元素的大小实现排序，如果后一个元素大于前一个元素，就交换这两个元素。这样就会让每一趟冒泡都能找到最大一个元素并放到最后。



以 [ 8, 1, 4, 6, 2, 3, 5, 7 ] 为例，对它进行冒泡排序：

![img](https://github.com/lefex/lefex.github.io/blob/master/images/all.005.jpeg?raw=true)

![img](https://github.com/lefex/lefex.github.io/blob/master/images/all.005.jpeg?raw=true)

![img](https://github.com/lefex/lefex.github.io/blob/master/images/all.005.jpeg?raw=true)

代码实现：



```
+ (NSArray *)bubbleSort:(NSArray *)unsortDatas {    NSMutableArray *unSortArray = [unsortDatas mutableCopy];    for (int i = 0; i < unSortArray.count -1 ; i++) {        BOOL isChange = NO;        for (int j = 0; j < unSortArray.count - 1 - i; j++) {            // 比较相邻两个元素的大小，后一个大于前一个就交换            if ([unSortArray[j] integerValue] > [unSortArray[j+1] integerValue]) {                NSNumber *data = unSortArray[j+1];                unSortArray[j+1] = unSortArray[j];                unSortArray[j] = data;                isChange = YES;            }        }        if (!isChange) {            // 如果某次未发生数据交换，说明数据已排序            break;        }    }    return [unSortArray copy];}
```



#### 特点

稳定性：它是指对同样的数据进行排序，会不会改变它的相对位置。比如 [ 1, 3, 2, 4, 2 ] 经过排序后，两个相同的元素 2 位置会不会被交换。冒泡排序是比较相邻两个元素的大小，显然不会破坏稳定性。

空间复杂度：由于整个排序过程是在原数据上进行操作，故为 O(1);

时间复杂度：最后的情况 O(n*n)，平均为 O(nlgn);



#### 感想

冒泡排序在排序的过程中设置一个 Flag 标记是否已经有序，会减少冒泡排序的趟数。它更适合基本有序的数据，只有几个无序，最好的情况时间复杂度为 O ( n )。它的基本操是每次找出最大的元素放到最后。



#### 推荐阅读：

[编程的背后](http://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&mid=2247483806&idx=1&sn=b85f43e846e96433755c7dc6adc1d033&chksm=fabb010dcdcc881b242ad387e6da4ea4174b99f5423d7bed11cc07dcd2af92f3ac00ebfc4ee8&scene=21#wechat_redirect)

<img style="border-radius: 30px" src="https://github.com/lefex/LeetCodeGraphically/blob/master/images/cyjs_qr.png?raw=true" title="lefex" width="200"/>



