---
layout: post
title:  "图解排序 7/10 - 计数排序"
date:   2019-04-07 09:28:47 +0800
categories: jekyll update
---

> 本文首次发表于超越技术公众号 [图解排序 7/10 - 计数排序](https://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&mid=2247483892&idx=1&sn=2af95b49be0ac263a9fa16444c06a360&chksm=fabb0167cdcc8871c15cf1bb85ef625cc4395e91cbe8f81bdbcb1e47a3d8af30310b0adb4f79&scene=21#wechat_redirect)



前面所讲的 6 种排序都是基于「比较」的思想，总是在比较两个元素的大小，然后交换位置。今天换个“口味”，来看看计数排序。计数排序的核心思想是把一个无序序列 A 转换成另一个有序序列 B，从 B 中逐个“取出”所有元素，取出的元素即为有序序列「没看明白，不急，后面来张图就搞明白了」。这种算法比快速排序还要快「特定条件下」，它适用于待排序序列中元素的取值范围比较小。比如对某大型公司员工按年龄排序，年龄的取值范围很小，大约在（10-100）之间。

## 计数排序

对数组 arr = [ 8, 1, 4, 6, 2, 3, 5, 4 ] 进行排序，使用计数排序需要找到与其对应的一个有序序列，可以使用数组的下标与 arr 做一个映射「数组的下标恰好是有序的」。遍历 arr，把 arr 中的元素放到 counArr 中，counArr 的大小是由 arr 中最大元素和最小元素决定的。「 一图胜千言 」

![img](https://github.com/lefex/LeetCodeGraphically/blob/master/assets/images/7-count/all.054.jpeg?raw=true)

图中有个技巧，为了让 countArr 尽可能地小，countArr 的长度使用了 arr 中的最大值 max - arr 中的最小值 min +
1 （max - min + 1），arr[i] - min 恰好是 countArr 的下标。countArr 
中记录了某个值出现的次数，比如 8 出现过 1 次，则在 countArr 中的值为 1；4 出现过 2 次，则在 countArr 中的值为 
2。

## 特点

稳定性：在元素往 countArr 中记录时按顺序遍历，从 countArr 中取出元素也是按顺序取出，相同元素相对位置不会发生变化，故稳定。

空间复杂度：需要额外申请空间，复杂度为“桶”的个数，故为 O ( k )， k 为“桶”的个数，也就是 countArr 的长度;

时间复杂度：最好最坏都为 O(n+k)， k 为“桶”的个数，也就是 countArr 的长度;



## 感想

这种排序不同于其它的「比较」排序，它巧妙地把待排序序列与某个有序序列建立关系，从有序列中通过这种关系再把元素计算出来，就达到了排序的目的。这种对于数据量大，但是数据取值范围比较小的序列非常适用。这种排序思想其实是一种“桶排序”的思想，下一篇会介绍。



**代码实现请前往 GitHub 项目[LeetCodeGraphically](https://github.com/lefex/LeetCodeGraphically)**



## 推荐阅读：

[编程的背后](http://mp.weixin.qq.com/s?__biz=MzUzMTk3ODc0OA==&mid=2247483806&idx=1&sn=b85f43e846e96433755c7dc6adc1d033&chksm=fabb010dcdcc881b242ad387e6da4ea4174b99f5423d7bed11cc07dcd2af92f3ac00ebfc4ee8&scene=21#wechat_redirect)



<img style="border-radius: 30px" src="https://github.com/lefex/LeetCodeGraphically/blob/master/images/cyjs_qr.png?raw=true" title="lefex" width="200"/>



